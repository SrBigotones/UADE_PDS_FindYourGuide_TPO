@startuml TPO

abstract class Usuario{
    - nombre: String
    - apellido: String
    - sexo: String
    - dni: String
    - email: String
    - numTelefono: String
    - imgPerfil: String
    ''Nombre del archivo, planificar ubicar la imagen en un servidor publico'
}


class UsuarioGuia extends Usuario{
    - listaCiudadActivo: Set<CiudadPais>
    - listaServicios: Set<ServicioGuia>

    + agregarServicio(ServicioGuia)
    + eliminarServicio(ServicioGuia)
}
UsuarioGuia *--> ServicioGuia
UsuarioGuia o-> CiudadPais

class UsuarioTurista extends Usuario{
}

abstract class ServicioGuia{
    - precio: double
    ''ver como aplica en las traducciones, si cobra tarifa por hora/dia/archivo/precio base
    - nombre: String
    - descripcion: String
}

abstract class Tour extends ServicioGuia{
    - ciudad: Ciudad
}

class TourIndividual extends Tour{}
class TourGrupal extends Tour{
    - cantPersonas: int
}

class Traduccion extends ServicioGuia{
    - idiomaOriginal: Idioma
    - idiomaDestino: Idioma
}

Traduccion *--> Idioma

enum Idioma{
    ESPANOL
    INGLES
    FRANCES
    ITALIANO
    ALEMAN
    GUARANI
    ETC...
}


class ControladorIA{
    ''PREGUNTAR AL PROFE!!!
    + confirmarVerificacion(EstadoVerificacionDTO)
    - enviarPush(EstadoVerificacionDTO)
    ''Cola de mensajes, no sabemos etapa de tiempo
}

class EstadoVerificacionDTO{
    - email: String
    - estado: Boolean
}

''Ver capa de servicios, si lo implementamos ahora 

class ServicioRegistro{
    - verificacionGuia: IVerificacionGuia

    + registrar(RegistroDTO)
    + verificarGuia(RegistroDTO)
}

''Ver si los contraladores usamos singleton
class ControladorRegistro{
    - servicioRegistro: ServicioRegistro

    + registro(RegistroDTO) ''POST
}
ServicioRegistro ..> IVerificacionGuia
ServicioRegistro ..> IMetodoRegistroAdapter
ControladorRegistro *-> ServicioRegistro


interface IMetodoRegistroAdapter{

    + registrar(RegistroDTO)
}

class AdapterRegistroGoogle implements IMetodoRegistroAdapter{
    - adaptada: AdaptadaRegistroGoogle
}
class AdapterRegistroApple implements IMetodoRegistroAdapter{
    - adaptada: AdaptadaRegistroApple
}
class AdapterRegistroFacebook implements IMetodoRegistroAdapter{
    - adaptada: AdaptadaRegistroFacebook
}

class RegistroDTO{
    ''Ver con el profe, tiene sentido meter todo en un solo DTO? Dejamos la responsabilidad de tomar los campos que valen en la implementacion concreta del adapter?
    ''En el caso de Guia, la verificacion, los datos de imagen y num de certificado, lo agregamos a este dto o lo separamos?
    - email: String
    - passwd: String
    - apiServicio: String
    - tipoUsuario: TipoUsuario
    - acreditacion: String
    - imgCredencial: String
}

enum TipoUsuario{
    GUIA
    TURISTA
}

ControladorRegistro o--> RegistroDTO



interface IVerificacionGuia{
    + verificar(VerificaGuiaDTO)
}

class VerificacionIA implements IVerificacionGuia{
    - apiConcreta: AdaptadaVerificacionIA

    + verificar(VerificaGuiaDTO)
}



'Estos metodos capas tiene mas sentido meterlos todo en un solo controlador por ejemplo: ControladorUsuarioTurista
class ControladorGuia{
    + buscarGuia(long): GuiaDTO
    + buscarGuias(FiltroDTO): List<UsuarioGuia>
}

ControladorGuia o-> FiltroDTO
class FiltroDTO{
    - paisCiudad: List<CiudadPais>
    - nombre: String
    - apellido: String
    - idiomas: List<Idioma>
    - servicios: List<Servicio>
    - puntacion: int
}
class ControladorContrato{
    + contratarTourGuia(ContratoTourDTO)
    + contratarTraduccionGuia(ContratoTraduccionDTO)

    + cancelarReserva(ReservaDTO)
}

class Review{
    - usuarioTurista: UsuarioTurista
    - usuarioGuia: UsuarioGuia
    - servicioContratado: ServicioGuia
    - calificacion: int 
    ''del 1 al 10
    - comentario: String
}

''No se donde poner esto por el momento :v
''Sabemos que son diferentes API para los diferentes metoods, asique seguro nos va a estar pidiendo implentar patron Adapter
interface INotificacion{
    + notificar(UsuarioDestino, mensaje)
}


interface ISistemaPago{
    + cobrar()
    + transferir()
    + depositar()
}


class CiudadPais{
    - id: long
    - ciudad: String
    - pais: String
}


class Contrato{
    - servicio: Servicio
    - usuarioContratante: UsuarioTurista
    - usuarioContratado: UsuarioGuia
    - fechaIni: Date
    - fechaFin: Date
    - importe: Double
    - estado: IStateContrato


    - cambiarEstado(IStateContrato)
}


interface IStateContrato{
    + pagar(Contrato)
    + cancelar(Contrato)
    + aprobar(Contrato)
    + realizarReserva(Contrato)
}

class StateContratoReserva implements IStateContrato{}
class StateContratoAceptado implements IStateContrato{}
class StateContratoConcluido implements IStateContrato{}
class StateContratoCancelado implements IStateContrato{}

Contrato o-> IStateContrato
ControladorContrato ..> Contrato

StateContratoReserva ..> StateContratoCancelado
StateContratoReserva ..> StateContratoAceptado
StateContratoAceptado ..> StateContratoConcluido
StateContratoAceptado ..> StateContratoCancelado

@enduml